<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hagrid – DSS Refund Auditor & Tour Deadline Monitor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f7;
    }
    #app {
      padding: 16px;
      box-sizing: border-box;
    }
    .hagrid-layout {
      display: flex;
      flex-direction: row;
      gap: 16px;
    }
    .hagrid-column {
      flex: 1;
      background: #ffffff;
      border-radius: 6px;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.06);
      padding: 12px 16px;
      box-sizing: border-box;
      max-height: calc(100vh - 40px);
      overflow: auto;
    }
    .hagrid-column h2 {
      margin-top: 0;
      font-size: 16px;
    }
    .hagrid-section {
      margin-bottom: 12px;
    }
    .hagrid-label {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .hagrid-value {
      font-size: 13px;
      padding: 6px 8px;
      background: #f3f3f5;
      border-radius: 4px;
      word-break: break-word;
    }
    .hagrid-status-ok {
      color: #067d15;
      font-weight: 600;
    }
    .hagrid-status-warn {
      color: #b85c00;
      font-weight: 600;
    }
    .hagrid-status-error {
      color: #cc0011;
      font-weight: 600;
    }
    .hagrid-badge {
      display: inline-block;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #e5e5f0;
      margin-right: 4px;
    }
    .hagrid-list {
      list-style: none;
      margin: 0;
      padding-left: 0;
      font-size: 13px;
    }
    .hagrid-list li {
      padding: 4px 0;
      border-bottom: 1px solid #ececf5;
    }
    .hagrid-list li:last-child {
      border-bottom: none;
    }
    .hagrid-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 13px;
      border: 1px solid #d0d0e0;
      background: #ffffff;
      cursor: pointer;
      margin-right: 6px;
      margin-top: 6px;
    }
    .hagrid-button-primary {
      background: #2f60d8;
      border-color: #2f60d8;
      color: #ffffff;
    }
    .hagrid-button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    .hagrid-log {
      font-size: 11px;
      max-height: 150px;
      overflow: auto;
      background: #0c0c0f;
      color: #e5e5ff;
      padding: 6px 8px;
      border-radius: 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      margin-top: 6px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="hagrid-layout">
      <!-- Left column: DSS Refund Auditor -->
      <div class="hagrid-column" id="dss-column">
        <h2>DSS Refund Auditor</h2>
        <div class="hagrid-section">
          <div class="hagrid-label">Ticket Summary</div>
          <div class="hagrid-value" id="dss-ticket-summary">Loading ticket data...</div>
        </div>
        <div class="hagrid-section">
          <div class="hagrid-label">Audit Result</div>
          <div class="hagrid-value" id="dss-audit-result">Not audited yet.</div>
        </div>
        <div class="hagrid-section">
          <div class="hagrid-label">Decision</div>
          <div class="hagrid-value" id="dss-decision">–</div>
        </div>
        <div class="hagrid-section">
          <button class="hagrid-button-primary hagrid-button" id="btn-run-audit">
            Run DSS Audit
          </button>
          <button class="hagrid-button" id="btn-save-to-sheets">
            Save Audit to Sheets
          </button>
        </div>
        <div class="hagrid-section">
          <div class="hagrid-label">Audit Log</div>
          <div class="hagrid-log" id="dss-log"></div>
        </div>
      </div>

      <!-- Right column: Tour Deadline Monitor -->
      <div class="hagrid-column" id="tour-column">
        <h2>Tour Deadline Monitor</h2>
        <div class="hagrid-section">
          <div class="hagrid-label">Tour status</div>
          <div class="hagrid-value" id="tour-status">Loading tour details...</div>
        </div>
        <div class="hagrid-section">
          <div class="hagrid-label">Upcoming deadlines</div>
          <ul class="hagrid-list" id="tour-deadlines-list">
            <li>Loading...</li>
          </ul>
        </div>
        <div class="hagrid-section">
          <div class="hagrid-label">Alerts</div>
          <div class="hagrid-value" id="tour-alerts">No alerts yet.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ZAF SDK -->
  <script src="https://static.zdassets.com/zendesk_app_framework_sdk/2.0/zaf_sdk.min.js"></script>

  <!-- Consolidated JS -->
  <script>
    /******************************************************************
     * config.js (inline)
     ******************************************************************/

    // Global ZAF client
    window.client = ZAFClient.init();

    const CONFIG = {
      appName: 'Hagrid',
      llmApis: {
        primary: {
          provider: 'google-gemini',
          endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent',
          apiKey: ''
        },
        fallback: {
          provider: 'huggingface',
          endpoint: 'https://api-inference.huggingface.co/models',
          model: 'meta-llama/Llama-3-8b-Instruct',
          apiKey: ''
        },
        timeoutMs: 15000,
        maxRetries: 2,
        retryDelayMs: 1200
      },
      googleSheets: {
        spreadsheetId: '',
        sheetName: 'Refund Audits',
        apiEndpoint: 'https://sheets.googleapis.com/v4/spreadsheets',
        serviceAccountEmail: '',
        serviceAccountKey: '',
        proxyUrl: '',
        columns: [
          'Timestamp',
          'Ticket ID',
          'Requester',
          'Refund Amount',
          'Currency',
          'Decision',
          'Reason',
          'Agent',
          'Tags',
          'Raw Analysis'
        ]
      },
      dss: {
        enabled: true,
        maxSummaryLength: 3000
      }
    };

    async function loadConfig() {
      const cfg = { ...CONFIG };

      try {
        if (typeof window.client !== 'undefined') {
          const metadata = await window.client.metadata();

          cfg.llmApis.primary.apiKey =
            metadata.settings.googleGeminiApiKey || cfg.llmApis.primary.apiKey || '';
          cfg.llmApis.fallback.apiKey =
            metadata.settings.huggingfaceApiKey || cfg.llmApis.fallback.apiKey || '';

          cfg.googleSheets.serviceAccountEmail =
            metadata.settings.serviceAccountEmail || cfg.googleSheets.serviceAccountEmail || '';
          cfg.googleSheets.serviceAccountKey =
            metadata.settings.serviceAccountKey || cfg.googleSheets.serviceAccountKey || '';
          cfg.googleSheets.proxyUrl =
            metadata.settings.googleSheetsProxyUrl || cfg.googleSheets.proxyUrl || '';
        }
      } catch (e) {
        console.error('Failed to load app metadata:', e);
      }

      return cfg;
    }

    /******************************************************************
     * dss_grid.json as JS variable
     * Replace this stub with your actual JSON.
     ******************************************************************/
    const DSS_GRID = {
      // Paste your full dss_grid.json content here as a JS object
      // Example structure:
      // "rules": [
      //   { "id": "rule_1", "description": "Sample rule", "conditions": [...], "outcome": "APPROVE" }
      // ]
    };

    /******************************************************************
     * time-utils.js (inline)
     ******************************************************************/
    const TimeUtils = {
      parseDate(value) {
        if (!value) return null;
        const d = new Date(value);
        return isNaN(d.getTime()) ? null : d;
      },
      formatDateTime(date) {
        if (!date) return '';
        return date.toISOString();
      },
      minutesBetween(a, b) {
        if (!a || !b) return null;
        return Math.round((b.getTime() - a.getTime()) / 60000);
      },
      isPast(date) {
        if (!date) return false;
        return date.getTime() < Date.now();
      },
      isWithinHours(from, hours) {
        if (!from) return false;
        const diffMs = from.getTime() - Date.now();
        return diffMs <= hours * 3600000 && diffMs >= 0;
      }
    };

    /******************************************************************
     * conversation-analyzer.js (inline)
     ******************************************************************/
    class ConversationAnalyzer {
      constructor(config) {
        this.config = config;
        this.primaryApi = config.llmApis.primary;
        this.fallbackApi = config.llmApis.fallback;
        this.timeoutMs = config.llmApis.timeoutMs || 15000;
        this.maxRetries = config.llmApis.maxRetries || 2;
        this.retryDelayMs = config.llmApis.retryDelayMs || 1200;
      }

      async analyzeConversation(ticketData, dssGrid) {
        const prompt = this.buildPrompt(ticketData, dssGrid);
        let lastError = null;

        if (this.primaryApi.apiKey) {
          try {
            return await this.callGemini(prompt);
          } catch (e) {
            lastError = e;
            console.warn('Gemini primary failed, falling back:', e);
          }
        }

        if (this.fallbackApi.apiKey) {
          try {
            return await this.callHuggingFace(prompt);
          } catch (e) {
            lastError = e;
            console.error('Hugging Face fallback failed:', e);
          }
        }

        throw lastError || new Error('No LLM configured');
      }

      buildPrompt(ticketData, dssGrid) {
        const {
          id,
          subject,
          description,
          tags,
          requester,
          assignee,
          customFields
        } = ticketData || {};

        return [
          'You are a refund compliance auditor.',
          'Use the provided DSS rules to evaluate whether the requested refund is allowed.',
          '',
          'DSS grid (rules):',
          JSON.stringify(dssGrid),
          '',
          'Ticket data:',
          `ID: ${id || 'N/A'}`,
          `Subject: ${subject || ''}`,
          `Description: ${description || ''}`,
          `Tags: ${(tags || []).join(', ')}`,
          `Requester: ${requester || ''}`,
          `Assignee: ${assignee || ''}`,
          `Custom fields: ${JSON.stringify(customFields || {})}`,
          '',
          'Return a concise JSON with keys: decision (APPROVE/REJECT/ESCALATE), reason, refundAmount, currency, notes.'
        ].join('\n');
      }

      async callGemini(prompt) {
        if (!this.primaryApi.apiKey) {
          throw new Error('Google Gemini API key not configured');
        }

        const url = `${this.primaryApi.endpoint}?key=${encodeURIComponent(this.primaryApi.apiKey)}`;
        const body = {
          contents: [
            {
              parts: [
                { text: prompt }
              ]
            }
          ]
        };

        const response = await this.fetchWithTimeout(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Gemini error: ${response.status} ${text}`);
        }

        const data = await response.json();
        const text =
          data.candidates?.[0]?.content?.parts?.[0]?.text ||
          data.candidates?.[0]?.output_text ||
          '';

        return this.parseModelResponse(text);
      }

      async callHuggingFace(prompt) {
        if (!this.fallbackApi.apiKey) {
          throw new Error('Hugging Face API key not configured');
        }

        const url = `${this.fallbackApi.endpoint}/${encodeURIComponent(this.fallbackApi.model)}`;
        const response = await this.fetchWithTimeout(url, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.fallbackApi.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ inputs: prompt })
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Hugging Face error: ${response.status} ${text}`);
        }

        const data = await response.json();
        const text = Array.isArray(data)
          ? (data[0]?.generated_text || JSON.stringify(data[0]))
          : (data.generated_text || JSON.stringify(data));

        return this.parseModelResponse(text);
      }

      async fetchWithTimeout(url, options) {
        const ctrl = new AbortController();
        const timeout = setTimeout(() => ctrl.abort(), this.timeoutMs);

        try {
          return await fetch(url, { ...options, signal: ctrl.signal });
        } finally {
          clearTimeout(timeout);
        }
      }

      parseModelResponse(text) {
        const match = text.match(/\{[\s\S]*\}/);
        if (match) {
          try {
            return JSON.parse(match[0]);
          } catch (e) {
            console.warn('Failed to parse JSON from model response, returning raw text');
          }
        }
        return {
          rawText: text
        };
      }
    }

    /******************************************************************
     * sheets-writer.js (inline, proxy-based)
     ******************************************************************/
    class SimplifiedSheetsWriter {
      constructor(config) {
        this.config = config;
        this.proxyUrl = config.googleSheets.proxyUrl || '';
        this.columns = config.googleSheets.columns || [];
      }

      async writeAuditResult(auditData) {
        if (!this.proxyUrl) {
          throw new Error('Google Sheets proxy URL not configured');
        }

        const row = this.buildRow(auditData);

        const response = await fetch(this.proxyUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ row })
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Sheets proxy error: ${response.status} ${text}`);
        }

        return await response.json();
      }

      buildRow(auditData) {
        const nowIso = new Date().toISOString();
        const safe = (v) => (v == null ? '' : String(v));

        const row = [
          nowIso,
          safe(auditData.ticketId),
          safe(auditData.requester),
          safe(auditData.refundAmount),
          safe(auditData.currency),
          safe(auditData.decision),
          safe(auditData.reason),
          safe(auditData.agent),
          (auditData.tags || []).join(', '),
          safe(auditData.rawAnalysis)
        ];

        if (row.length < this.columns.length) {
          while (row.length < this.columns.length) {
            row.push('');
          }
        } else if (row.length > this.columns.length) {
          row.length = this.columns.length;
        }

        return row;
      }
    }

    /******************************************************************
     * tour-deadline.js (inline, simplified)
     * Adjust custom field IDs as per your instance.
     ******************************************************************/
    const TourDeadlineMonitor = (function () {
      async function getTourData(client) {
        const [ticket, custom] = await Promise.all([
          client.get('ticket'),
          client.get('ticket.customField:custom_field_tour_date') // adjust field id
        ]);

        const ticketData = ticket.ticket || {};
        const tourDateRaw = custom['ticket.customField:custom_field_tour_date'];

        return {
          ticket: ticketData,
          tourDate: TimeUtils.parseDate(tourDateRaw),
          rawTourDate: tourDateRaw
        };
      }

      function buildDeadlines(tourDate) {
        if (!tourDate) return [];

        const ms = tourDate.getTime();
        return [
          {
            label: '72 hours before tour',
            time: new Date(ms - 72 * 3600000)
          },
          {
            label: '24 hours before tour',
            time: new Date(ms - 24 * 3600000)
          },
          {
            label: '2 hours before tour',
            time: new Date(ms - 2 * 3600000)
          }
        ];
      }

      function describeDeadlines(deadlines) {
        const now = new Date();
        return deadlines.map((d) => {
          const diffMin = TimeUtils.minutesBetween(now, d.time);
          const past = diffMin < 0;
          const absMin = Math.abs(diffMin || 0);

          let status;
          if (past) {
            status = `Passed by ${absMin} min`;
          } else {
            status = `In ${absMin} min`;
          }

          return {
            label: d.label,
            time: TimeUtils.formatDateTime(d.time),
            status,
            past
          };
        });
      }

      function renderDeadlines(descriptors) {
        const list = document.getElementById('tour-deadlines-list');
        if (!list) return;

        list.innerHTML = '';
        if (!descriptors.length) {
          list.innerHTML = '<li>No deadlines configured.</li>';
          return;
        }

        descriptors.forEach((d) => {
          const li = document.createElement('li');
          li.innerHTML = `
            <div><span class="hagrid-badge">${d.label}</span></div>
            <div>${d.time}</div>
            <div class="${d.past ? 'hagrid-status-warn' : 'hagrid-status-ok'}">${d.status}</div>
          `;
          list.appendChild(li);
        });
      }

      function renderAlerts(descriptors) {
        const el = document.getElementById('tour-alerts');
        if (!el) return;

        const overdue = descriptors.filter((d) => d.past);
        if (!overdue.length) {
          el.textContent = 'No overdue deadlines.';
          return;
        }

        el.textContent =
          overdue.length === 1
            ? `1 deadline has passed: ${overdue[0].label}`
            : `${overdue.length} deadlines have passed.`;
      }

      async function refresh(client) {
        try {
          const { tourDate, rawTourDate } = await getTourData(client);
          const statusEl = document.getElementById('tour-status');
          if (statusEl) {
            statusEl.textContent = tourDate
              ? `Tour date: ${rawTourDate}`
              : 'No tour date set.';
          }

          const deadlines = buildDeadlines(tourDate);
          const descriptors = describeDeadlines(deadlines);
          renderDeadlines(descriptors);
          renderAlerts(descriptors);
        } catch (e) {
          console.error('TourDeadlineMonitor.refresh error:', e);
          const statusEl = document.getElementById('tour-status');
          if (statusEl) {
            statusEl.textContent = `Error reading tour data: ${e.message}`;
          }
        }
      }

      return { refresh };
    })();

    /******************************************************************
     * app.js (inline main logic)
     ******************************************************************/
    (async function () {
      const client = window.client || ZAFClient.init();
      const config = await loadConfig();
      const analyzer = new ConversationAnalyzer(config);
      const sheetsWriter = new SimplifiedSheetsWriter(config);

      const logEl = document.getElementById('dss-log');
      const summaryEl = document.getElementById('dss-ticket-summary');
      const resultEl = document.getElementById('dss-audit-result');
      const decisionEl = document.getElementById('dss-decision');
      const btnRun = document.getElementById('btn-run-audit');
      const btnSave = document.getElementById('btn-save-to-sheets');

      let lastAuditResult = null;

      function log(line) {
        if (!logEl) return;
        const ts = new Date().toISOString();
        logEl.textContent += `[${ts}] ${line}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function getTicketContext() {
        const [
          ticketResponse,
          requesterResponse,
          assigneeResponse,
          tagsResponse
        ] = await Promise.all([
          client.get('ticket'),
          client.get('ticket.requester'),
          client.get('ticket.assignee'),
          client.get('ticket.tags')
        ]);

        const ticket = ticketResponse.ticket || {};
        const requester = requesterResponse['ticket.requester'] || {};
        const assignee = assigneeResponse['ticket.assignee'] || {};
        const tags = tagsResponse['ticket.tags'] || [];

        return {
          id: ticket.id,
          subject: ticket.subject,
          description: ticket.description,
          tags,
          requester: requester.name || requester.email || '',
          assignee: assignee.name || '',
          customFields: ticket.custom_fields || []
        };
      }

      function renderTicketSummary(ticket) {
        if (!summaryEl) return;
        if (!ticket) {
          summaryEl.textContent = 'No ticket data found.';
          return;
        }

        summaryEl.textContent = [
          `#${ticket.id || ''} – ${ticket.subject || ''}`,
          '',
          ticket.description || ''
        ].join('\n');
      }

      function renderAuditResult(result) {
        if (!resultEl || !decisionEl) return;
        if (!result) {
          resultEl.textContent = 'No result.';
          decisionEl.textContent = '–';
          return;
        }

        const decision = result.decision || result.Decision || result.decisionText || 'UNKNOWN';
        const reason = result.reason || result.Reason || '';
        const amount = result.refundAmount || result.amount || '';
        const currency = result.currency || result.Currency || '';

        resultEl.textContent = [
          `Decision: ${decision}`,
          reason ? `Reason: ${reason}` : '',
          amount ? `Amount: ${amount} ${currency || ''}` : ''
        ]
          .filter(Boolean)
          .join('\n');

        decisionEl.textContent = decision;
      }

      async function runAudit() {
        try {
          if (btnRun) btnRun.disabled = true;
          if (btnSave) btnSave.disabled = true;
          log('Starting DSS audit...');

          const ticket = await getTicketContext();
          renderTicketSummary(ticket);

          log('Calling LLM for analysis...');
          const result = await analyzer.analyzeConversation(ticket, DSS_GRID);
          lastAuditResult = { ticket, result };

          log('Audit completed.');
          renderAuditResult(result);
          if (btnSave) btnSave.disabled = false;
        } catch (e) {
          console.error('runAudit error:', e);
          log(`Error running audit: ${e.message}`);
          renderAuditResult(null);
        } finally {
          if (btnRun) btnRun.disabled = false;
        }
      }

      async function saveAuditToSheets() {
        if (!lastAuditResult) {
          log('No audit result to save.');
          return;
        }
        try {
          if (btnSave) btnSave.disabled = true;
          log('Sending audit to Google Sheets proxy...');

          const { ticket, result } = lastAuditResult;
          const payload = {
            ticketId: ticket.id,
            requester: ticket.requester,
            refundAmount: result.refundAmount || '',
            currency: result.currency || '',
            decision: result.decision || '',
            reason: result.reason || '',
            agent: ticket.assignee,
            tags: ticket.tags,
            rawAnalysis: JSON.stringify(result)
          };

          const response = await sheetsWriter.writeAuditResult(payload);
          log(`Sheets write OK: ${JSON.stringify(response)}`);
        } catch (e) {
          console.error('saveAuditToSheets error:', e);
          log(`Error writing to Sheets: ${e.message}`);
        } finally {
          if (btnSave) btnSave.disabled = false;
        }
      }

      if (btnRun) {
        btnRun.addEventListener('click', runAudit);
      }
      if (btnSave) {
        btnSave.addEventListener('click', saveAuditToSheets);
      }

      try {
        const ticket = await getTicketContext();
        renderTicketSummary(ticket);
        log('Ticket loaded.');
      } catch (e) {
        console.error('Initial ticket load error:', e);
        log(`Error loading ticket: ${e.message}`);
      }

      client.on('ticket.tags.changed', () => {
        TourDeadlineMonitor.refresh(client).catch((e) =>
          console.error('TourDeadlineMonitor refresh on tags change:', e)
        );
      });

      client.on('ticket.custom_field_changed', () => {
        TourDeadlineMonitor.refresh(client).catch((e) =>
          console.error('TourDeadlineMonitor refresh on custom field change:', e)
        );
      });

      TourDeadlineMonitor.refresh(client).catch((e) =>
        console.error('Initial TourDeadlineMonitor refresh error:', e)
      );
    })();
  </script>
</body>
</html>
